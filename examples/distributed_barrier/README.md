# DistributedBarrier

## Общее назначение

`DistributedBarrier` — это класс для управления распределённым барьером с использованием Redis, предназначенный для
синхронизации заданного числа участников (parties). Каждый участник должен достичь барьера, прежде чем все они смогут
продолжить выполнение. Это полезно в сценариях, где требуется, чтобы несколько процессов или задач одновременно достигли
определённой точки выполнения, прежде чем продолжить.

## Использование Redis

Для координации состояния барьера используются Redis и его возможности публикации и подписки. Ключ `_count_key`
отслеживает количество участников, достигших барьера, а через канал `_channel_name` происходит уведомление о том, что
все участники готовы продолжить.

## Методы класса

### `__init__(self, redis: 'Redis[Any]', key: str, parties: int)`

Инициализирует распределённый барьер.

- `redis`: клиент Redis для управления барьером.
- `key`: уникальный идентификатор барьера в системе Redis.
- `parties`: количество участников, которые должны достичь барьера для продолжения.

### `async wait(self) -> None`

Ожидает, пока все участники не достигнут барьера. Если барьер сброшен или прерван, возбуждается
исключение `BrokenBarrierError`.

### `async _reset_count(self) -> None`

Сбрасывает счётчик участников барьера.

### `async _publish_release(self) -> None`

Оповещает всех участников о том, что барьер достигнут и они могут продолжить выполнение.

### `async reset(self) -> None`

Сбрасывает барьер и оповещает участников о сбросе, позволяя начать процесс заново.

### `async abort(self) -> None`

Прерывает ожидание у барьера и оповещает участников о прерывании.

## Примеры использования

1. **Координация начала обработки данных.** Используйте `DistributedBarrier` для синхронизации начала обработки данных,
   когда данные должны быть обработаны одновременно в разных частях системы.
2. **Синхронизация распределённых задач.** Обеспечьте, что все задачи в распределённой системе достигли логической точки
   выполнения, прежде чем продолжить.
3. **Управление потоками в многопоточных приложениях.** В сценариях, где несколько потоков или процессов должны ожидать
   друг друга для безопасного доступа к ресурсам или для выполнения последующих операций.
