# DistributedCondition

## Общее назначение

`DistributedCondition` — это класс, предназначенный для управления условной синхронизацией между различными процессами,
использующими распределённый механизм. Класс использует Redis для поддержки синхронизации через условные переменные,
позволяя процессам ожидать изменения состояния, прежде чем продолжить выполнение.

## Использование Redis

Класс использует комбинацию Redis'овых механизмов публикации/подписки (Pub/Sub) и скриптов на Lua для управления
состоянием и синхронизации. Он интегрирует `DistributedLock` для управления блокировкой, что позволяет безопасно
изменять состояние и отправлять уведомления подписчикам.

## Методы класса

### `__init__(self, redis: 'Redis[Any]', key: str, acquire_sleep_delay: float = 0.1, acquire_timeout: float | None = None)`

Инициализирует экземпляр условной синхронизации.

- `redis`: клиент Redis, используемый для работы с условными переменными.
- `key`: базовый ключ, используемый для создания ключей и каналов в Redis.
- `acquire_sleep_delay`: задержка между попытками захвата блокировки.
- `acquire_timeout`: максимальное время ожидания захвата блокировки.

### `async wait(self) -> bool`

Ожидает уведомление. Блокирует выполнение, пока другой процесс не вызовет `notify` или `notify_all`.

### `async notify(self, n: int = 1) -> None`

Уведомляет `n` подписанных процессов, что они могут продолжить выполнение. Требует, чтобы вызывающий процесс владел
блокировкой.

### `async notify_all(self) -> None`

Уведомляет всех подписанных процессов, позволяя им продолжить выполнение. Также требует владения блокировкой.

### `async __aenter__(self) -> 'DistributedCondition'`

Асинхронно входит в контекст выполнения, автоматически захватывая блокировку.

### `async __aexit__(self, exc_type: type, exc: BaseException, tb: type) -> None`

Асинхронно выходит из контекста выполнения, автоматически освобождая блокировку.

## Примеры использования

1. **Синхронизация обработки данных.** Используйте `DistributedCondition` для ожидания завершения подготовительных
   процедур в других сервисах перед началом обработки данных.
2. **Координация параллельных задач.** Регулируйте выполнение задач, которые должны быть выполнены в строгом порядке,
   через механизм уведомлений.
3. **Управление ресурсами в микросервисной архитектуре.** Координируйте доступ к общим ресурсам, таким как базы данных
   или файловые системы, через условные переменные и блокировки.

## Запуск примера

```
docker-compose build
docker-compose up
curl http://localhost:8090/gather_stats
```
