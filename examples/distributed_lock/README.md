# DistributedLock

## Общее назначение

`DistributedLock` — это класс для управления распределённой блокировкой с использованием Redis. Такая блокировка
позволяет синхронизировать доступ к общим ресурсам между различными процессами или микросервисами, которые работают в
разных средах выполнения.

## Использование Redis

Для реализации механизма блокировки используется база данных Redis. Ключ `key`, представляющий блокировку, хранится в
Redis. Блокировка реализуется путём установки этого ключа со специальным токеном, который генерируется как уникальный
UUID для каждого экземпляра блокировки. Для освобождения блокировки используется LUA-скрипт, который удаляет ключ из
Redis, только если токен соответствует установленному.

## Методы класса

### `__init__(self, redis: 'Redis[Any]', key: str, acquire_sleep_delay: float = 0.1, acquire_timeout: float | None = None)`

Инициализирует экземпляр блокировки.

- `redis`: клиент Redis, который будет использоваться для управления блокировкой.
- `key`: ключ в Redis, который будет использоваться для хранения состояния блокировки.
- `acquire_sleep_delay`: задержка между попытками захвата блокировки в секундах.
- `acquire_timeout`: максимальное время попыток захвата блокировки в секундах.

### `async acquire(self, acquire_sleep_delay: float | None = None, acquire_timeout: float | None = None) -> bool`

Асинхронно пытается захватить блокировку.

- `acquire_sleep_delay`: переопределяет стандартную задержку между попытками захвата.
- `acquire_timeout`: переопределяет стандартное время ожидания захвата блокировки.

### `async release(self) -> None`

Асинхронно освобождает блокировку. Вызывает исключение `RuntimeError`, если блокировка не была захвачена этим
экземпляром.

### `async locked(self) -> bool`

Проверяет, захвачена ли блокировка в данный момент.

## Примеры использования

1. **Синхронизация доступа к общему ресурсу в микросервисной архитектуре.** Несколько микросервисов могут
   использовать `DistributedLock` для координации доступа к общей базе данных или файловому хранилищу.
2. **Предотвращение одновременного выполнения задачи.** Распределённые задачи, такие как ежедневные бэкапы или пакетная
   обработка данных, могут использовать блокировку для избежания одновременного выполнения.
3. **Управление доступом к ограниченным ресурсам.** Когда несколько процессов или сервисов конкурируют за ограниченный
   ресурс, блокировка может использоваться для обеспечения справедливого доступа.

## Запуск примера

```
docker-compose build
docker-compose up
curl http://localhost:8090/gather_stats
```
